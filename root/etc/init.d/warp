#!/bin/sh /etc/rc.common
# Copyright (C) 2024
# SPDX-License-Identifier: GPL-3.0-or-later

START=99
STOP=10
USE_PROCD=1

PROG=/usr/bin/warp-manager
CONFIG_FILE=/etc/config/warp
SOCKS_PID_FILE=/var/run/warp-socks.pid
PRE_PROXY_PID_FILE=/var/run/warp-pre-proxy.pid

get_config() {
    config_load warp
    config_get ENABLED config enabled 0
    config_get ENDPOINT config endpoint "engage.cloudflareclient.com:2408"
    config_get MTU config mtu 1280
    config_get DNS config dns "1.1.1.1"
    config_get IPV6 config ipv6 1
    config_get GLOBAL_PROXY config global_proxy 1
    config_get BYPASS_CHINA config bypass_china 0
    config_get PRIVATE_KEY config private_key ""
    config_get PUBLIC_KEY config public_key ""
    config_get ADDRESS_V4 config address_v4 ""
    config_get ADDRESS_V6 config address_v6 ""
    config_get RESERVED config reserved ""
    config_get SOCKS_PORT config socks_port "1080"
    config_get SOCKS_ENABLED config socks_enabled "1"
    
    # 前置代理配置
    config_get PRE_PROXY_ENABLED config pre_proxy_enabled "0"
    config_get PRE_PROXY_TYPE config pre_proxy_type "socks5"
    config_get PRE_PROXY_ADDR config pre_proxy_addr ""
    config_get PRE_PROXY_PORT config pre_proxy_port ""
    config_get PRE_PROXY_USER config pre_proxy_user ""
    config_get PRE_PROXY_PASS config pre_proxy_pass ""
}

setup_pre_proxy() {
    get_config
    
    [ "$PRE_PROXY_ENABLED" != "1" ] && return 0
    [ -z "$PRE_PROXY_ADDR" ] || [ -z "$PRE_PROXY_PORT" ] && {
        logger -t warp "Pre-proxy enabled but address/port not configured"
        return 1
    }
    
    # 停止现有前置代理
    stop_pre_proxy
    
    # 解析WARP endpoint
    local endpoint_host="${ENDPOINT%:*}"
    local endpoint_port="${ENDPOINT##*:}"
    
    # 解析endpoint IP
    local endpoint_ip=$(nslookup "$endpoint_host" 2>/dev/null | grep -A1 "Name:" | grep "Address" | awk '{print $2}' | head -1)
    [ -z "$endpoint_ip" ] && endpoint_ip=$(ping -c1 "$endpoint_host" 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    
    if [ -z "$endpoint_ip" ]; then
        logger -t warp "Cannot resolve endpoint: $endpoint_host"
        return 1
    fi
    
    logger -t warp "Setting up pre-proxy: $PRE_PROXY_TYPE://$PRE_PROXY_ADDR:$PRE_PROXY_PORT -> $endpoint_ip:$endpoint_port"
    
    # 使用gost建立前置代理通道
    if command -v gost >/dev/null 2>&1; then
        local forward_port=51820
        local auth_str=""
        
        if [ -n "$PRE_PROXY_USER" ] && [ -n "$PRE_PROXY_PASS" ]; then
            auth_str="${PRE_PROXY_USER}:${PRE_PROXY_PASS}@"
        fi
        
        # 创建UDP转发：本地51820 -> 前置代理 -> WARP endpoint
        if [ "$PRE_PROXY_TYPE" = "socks5" ]; then
            gost -L "udp://:${forward_port}/${endpoint_ip}:${endpoint_port}" \
                 -F "socks5://${auth_str}${PRE_PROXY_ADDR}:${PRE_PROXY_PORT}" &
        else
            gost -L "udp://:${forward_port}/${endpoint_ip}:${endpoint_port}" \
                 -F "http://${auth_str}${PRE_PROXY_ADDR}:${PRE_PROXY_PORT}" &
        fi
        echo $! > "$PRE_PROXY_PID_FILE"
        
        # 修改endpoint为本地转发端口
        ENDPOINT="127.0.0.1:${forward_port}"
        
        logger -t warp "Pre-proxy tunnel established via gost"
    else
        logger -t warp "gost not found. Install with: opkg install gost"
        logger -t warp "Pre-proxy requires gost for UDP forwarding"
        return 1
    fi
    
    return 0
}

stop_pre_proxy() {
    if [ -f "$PRE_PROXY_PID_FILE" ]; then
        kill $(cat "$PRE_PROXY_PID_FILE") 2>/dev/null
        rm -f "$PRE_PROXY_PID_FILE"
    fi
}

setup_interface() {
    get_config
    
    [ -z "$PRIVATE_KEY" ] && {
        logger -t warp "Error: Private key not configured"
        return 1
    }
    
    [ -z "$ADDRESS_V4" ] && {
        logger -t warp "Error: IPv4 address not configured"
        return 1
    }
    
    # 设置前置代理（如果启用）
    if [ "$PRE_PROXY_ENABLED" = "1" ]; then
        setup_pre_proxy || {
            logger -t warp "Failed to setup pre-proxy"
            return 1
        }
    fi
    
    # 删除现有的warp接口
    uci -q delete network.warp
    
    # 创建WireGuard接口
    uci set network.warp=interface
    uci set network.warp.proto='wireguard'
    uci set network.warp.private_key="$PRIVATE_KEY"
    uci set network.warp.mtu="$MTU"
    
    # 设置地址
    uci add_list network.warp.addresses="$ADDRESS_V4"
    [ "$IPV6" = "1" ] && [ -n "$ADDRESS_V6" ] && {
        uci add_list network.warp.addresses="$ADDRESS_V6"
    }
    
    # 设置DNS
    uci set network.warp.dns="$DNS"
    
    # 删除现有的peer
    uci -q delete network.warp_peer
    
    # 创建peer
    uci set network.warp_peer=wireguard_warp
    uci set network.warp_peer.public_key='bmXOC+F1FxEMF9dyiK2H5/1SUtzH0JuVo51h2wPfgyo='
    uci set network.warp_peer.endpoint_host="${ENDPOINT%:*}"
    uci set network.warp_peer.endpoint_port="${ENDPOINT##*:}"
    uci set network.warp_peer.persistent_keepalive='25'
    
    # 设置AllowedIPs
    if [ "$GLOBAL_PROXY" = "1" ]; then
        uci add_list network.warp_peer.allowed_ips='0.0.0.0/0'
        [ "$IPV6" = "1" ] && uci add_list network.warp_peer.allowed_ips='::/0'
    else
        uci add_list network.warp_peer.allowed_ips='0.0.0.0/0'
    fi
    
    # 设置reserved (如果有)
    [ -n "$RESERVED" ] && {
        uci set network.warp_peer.reserved="$RESERVED"
    }
    
    uci commit network
    
    # 设置防火墙规则
    setup_firewall
    
    # 设置路由
    setup_routes
    
    # 重启网络
    /etc/init.d/network reload
    
    # 等待接口启动
    sleep 3
    
    # 启动SOCKS代理
    [ "$SOCKS_ENABLED" = "1" ] && start_socks
    
    logger -t warp "WARP interface configured successfully"
    return 0
}

setup_routes() {
    get_config
    
    # 删除旧的路由配置
    uci -q delete network.warp_route
    uci -q delete network.warp_ep1
    uci -q delete network.warp_ep2
    uci -q delete network.warp_ep3
    uci -q delete network.warp_ep4
    
    if [ "$GLOBAL_PROXY" = "1" ]; then
        # 添加默认路由走warp
        uci set network.warp_route=route
        uci set network.warp_route.interface='warp'
        uci set network.warp_route.target='0.0.0.0/0'
        uci set network.warp_route.metric='10'
        
        # 获取当前WAN网关
        local wan_gw=$(ip route show default | grep -v warp | awk '{print $3}' | head -1)
        
        if [ -n "$wan_gw" ]; then
            # 保留Cloudflare endpoint的路由（避免死循环）
            # 如果使用前置代理，需要保留前置代理的路由
            if [ "$PRE_PROXY_ENABLED" = "1" ] && [ -n "$PRE_PROXY_ADDR" ]; then
                uci set network.warp_ep1=route
                uci set network.warp_ep1.interface='wan'
                uci set network.warp_ep1.target="${PRE_PROXY_ADDR}/32"
                uci set network.warp_ep1.gateway="$wan_gw"
            else
                uci set network.warp_ep1=route
                uci set network.warp_ep1.interface='wan'
                uci set network.warp_ep1.target='162.159.192.0/24'
                uci set network.warp_ep1.gateway="$wan_gw"
                
                uci set network.warp_ep2=route
                uci set network.warp_ep2.interface='wan'
                uci set network.warp_ep2.target='162.159.193.0/24'
                uci set network.warp_ep2.gateway="$wan_gw"
                
                uci set network.warp_ep3=route
                uci set network.warp_ep3.interface='wan'
                uci set network.warp_ep3.target='162.159.195.0/24'
                uci set network.warp_ep3.gateway="$wan_gw"
                
                uci set network.warp_ep4=route
                uci set network.warp_ep4.interface='wan'
                uci set network.warp_ep4.target='198.18.0.0/16'
                uci set network.warp_ep4.gateway="$wan_gw"
            fi
        fi
    fi
    
    uci commit network
    logger -t warp "Routes configured"
}

start_socks() {
    get_config
    
    # 停止现有的SOCKS代理
    stop_socks
    
    # 检查是否安装了gost或microsocks
    if command -v gost >/dev/null 2>&1; then
        # 使用gost作为SOCKS代理
        gost -L "socks5://0.0.0.0:${SOCKS_PORT}?bind=${ADDRESS_V4}" &
        echo $! > "$SOCKS_PID_FILE"
        logger -t warp "SOCKS5 proxy started on port $SOCKS_PORT (gost)"
    elif command -v microsocks >/dev/null 2>&1; then
        # 使用microsocks
        microsocks -i 0.0.0.0 -p "$SOCKS_PORT" -b "$ADDRESS_V4" &
        echo $! > "$SOCKS_PID_FILE"
        logger -t warp "SOCKS5 proxy started on port $SOCKS_PORT (microsocks)"
    else
        logger -t warp "No SOCKS proxy software found (gost/microsocks). SOCKS proxy disabled."
        logger -t warp "Install with: opkg install microsocks"
    fi
    
    # 添加防火墙规则允许SOCKS端口
    setup_socks_firewall
}

stop_socks() {
    if [ -f "$SOCKS_PID_FILE" ]; then
        kill $(cat "$SOCKS_PID_FILE") 2>/dev/null
        rm -f "$SOCKS_PID_FILE"
    fi
    # 清理可能残留的进程
    killall microsocks 2>/dev/null
}

setup_socks_firewall() {
    get_config
    
    # 检查是否已有socks规则
    local rule_exists=$(uci -q get firewall.warp_socks)
    
    if [ -z "$rule_exists" ]; then
        uci set firewall.warp_socks=rule
        uci set firewall.warp_socks.name='Allow-WARP-SOCKS'
        uci set firewall.warp_socks.src='lan'
        uci set firewall.warp_socks.dest_port="$SOCKS_PORT"
        uci set firewall.warp_socks.proto='tcp'
        uci set firewall.warp_socks.target='ACCEPT'
        uci commit firewall
        /etc/init.d/firewall reload
    fi
}

setup_firewall() {
    # 检查warp zone是否已存在
    local zone_exists=$(uci -q get firewall.warp_zone)
    
    if [ -z "$zone_exists" ]; then
        # 创建warp zone
        uci set firewall.warp_zone=zone
        uci set firewall.warp_zone.name='warp'
        uci set firewall.warp_zone.input='REJECT'
        uci set firewall.warp_zone.output='ACCEPT'
        uci set firewall.warp_zone.forward='REJECT'
        uci set firewall.warp_zone.masq='1'
        uci set firewall.warp_zone.mtu_fix='1'
        uci add_list firewall.warp_zone.network='warp'
        
        # 创建lan到warp的转发规则
        uci set firewall.lan_warp=forwarding
        uci set firewall.lan_warp.src='lan'
        uci set firewall.lan_warp.dest='warp'
        
        uci commit firewall
        /etc/init.d/firewall reload
    fi
}

remove_interface() {
    # 停止SOCKS代理
    stop_socks
    
    # 停止前置代理
    stop_pre_proxy
    
    # 删除WireGuard接口
    uci -q delete network.warp
    uci -q delete network.warp_peer
    uci -q delete network.warp_route
    uci -q delete network.warp_ep1
    uci -q delete network.warp_ep2
    uci -q delete network.warp_ep3
    uci -q delete network.warp_ep4
    uci commit network
    
    # 删除防火墙规则
    uci -q delete firewall.warp_zone
    uci -q delete firewall.lan_warp
    uci -q delete firewall.warp_socks
    uci commit firewall
    
    /etc/init.d/network reload
    /etc/init.d/firewall reload
    
    logger -t warp "WARP interface removed"
}

start_service() {
    get_config
    
    [ "$ENABLED" != "1" ] && {
        logger -t warp "WARP is disabled"
        return 0
    }
    
    setup_interface
}

stop_service() {
    remove_interface
}

reload_service() {
    stop_service
    start_service
}

service_triggers() {
    procd_add_reload_trigger "warp"
}
